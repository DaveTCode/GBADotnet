"use strict";

const connection = new signalR.HubConnectionBuilder().withUrl("/emulatorhub").build();

var backingCanvas;
var screenCanvas
var backingContext;
var screenContext;

/**
 * When a frame is generated by the backing application it will use signalr to 
 * trigger this function with a base 64 string version of the frame data.
 * 
 * This function is then responsible for drawing onto the canvas (and must 
 * obviously take less than 16ms or it will be called again in the interim 
 * period)
 */
connection.on("SendFrame", function (data) {
    if (!backingCanvas) backingCanvas = document.querySelector("#backing-canvas");
    if (!screenCanvas) screenCanvas = document.querySelector("#screen-canvas");
    if (!backingContext) backingContext = backingCanvas.getContext("2d");
    if (!screenContext) screenContext = screenCanvas.getContext("2d");

    const frameBytes = atob(data);
    const arr = new Uint8ClampedArray(frameBytes.length);

    for (let ii = 0; ii < arr.length; ii++) {
        if (ii % 4 == 3) {
            arr[ii] = 255;
        } else {
            arr[ii] = frameBytes.charCodeAt(ii);
        }
    }

    // Use a backing canvas to store the original unscaled data and then scale 
    // up by 2 * to get better resolution
    const imageData = new ImageData(arr, 240);
    backingContext.putImageData(imageData, 0, 0);
    screenContext.drawImage(backingCanvas, 0, 0, 240, 160, 0, 0, 480, 320);
});

/**
 * When the device is paused it will send the entire device object serialized 
 * so that we can pull interesting debug information out
 */
connection.on("SendDevice", function (device) {
    console.log(device);
});

// Start up the connection to the signalr backend
connection.start().catch(err => document.write(err));

// Note that this mapping must match the enum ordering in Key.cs
var keyMap = {
    "x": 0, // A
    "z": 1, // B
    "Backspace": 2, // Select
    "Enter": 3, // Start
    "ArrowRight": 4, // Right
    "ArrowLeft": 5, // Left
    "ArrowUp": 6, // Up
    "ArrowDown": 7, // Down
    "a": 8, // L
    "s": 9, // R
}

document.querySelector("#screen-canvas").addEventListener("keyup", function (e) {
    if (keyMap[e.key]) {
        connection.invoke("KeyUp", keyMap[e.key]);
    }
});

document.querySelector("#screen-canvas").addEventListener("keydown", function(e) {
    if (keyMap[e.key]) {
        connection.invoke("KeyDown", keyMap[e.key]);
    }
});

document.querySelector("#pause-button").addEventListener("click", function (e) {
    connection.invoke("Pause");
    document.querySelector("#resume-button").classList.remove("d-none");
    document.querySelector("#pause-button").classList.add("d-none");
});

document.querySelector("#resume-button").addEventListener("click", function (e) {
    connection.invoke("Resume");
    document.querySelector("#pause-button").classList.remove("d-none");
    document.querySelector("#resume-button").classList.add("d-none");
});

/**
 * Called when a rom is clicked, this will fire a POST to the backend server 
 * which will start running that rom.
 * 
 * @param {string} guid - The GUID of a ROM loaded from the server.
 */
function LoadRom(guid) {
    document.querySelector("#pause-button").classList.remove("disabled");
    document.querySelector("#stop-button").classList.remove("disabled");

    fetch("api/v1/rom/load?guid=" + guid, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: "",
    }).then((response) => {
        console.log(response);
    });
}